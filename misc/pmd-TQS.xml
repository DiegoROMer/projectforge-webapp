<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ruleset xmlns="http://pmd.sf.net/ruleset/1.0.0" name="pmd_TQS_080428" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd" xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd">
   <description>TQS</description>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidRethrowingException" message="A catch statement that catches an exception only to rethrow it should be avoided." name="AvoidRethrowingException" since="3.8" typeResolution="true">
      <description>
     Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.
    </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//CatchStatement[FormalParameter
 /VariableDeclaratorId/@Image = Block/BlockStatement/Statement
 /ThrowStatement/Expression/PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix/Name/@Image
 and count(Block/BlockStatement/Statement) =1]
 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[  
  public class Foo {
   void bar() {
    try {
    // do something
    }  catch (SomeException se) {
       throw se;
    }
   }
  }
  
    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonCaseLabelInSwitchStatement" message="A non-case label was present in a switch statement" name="NonCaseLabelInSwitchStatement" since="1.5" typeResolution="true">
      <description>
A non-case label (e.g. a named break/continue label) was present in a switch statement.
This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//SwitchStatement//BlockStatement/Statement/LabeledStatement
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.MoreThanOneLogger" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#MoreThanOneLogger" message="Class contains more than one logger." name="MoreThanOneLogger" since="2.0" typeResolution="true">
      <description>
Normally only one logger is used in each class.
     </description>
      <priority>5</priority>
      <example><![CDATA[
 
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is very rare to see two loggers on a class, normally
    // log information is multiplexed by levels
    Logger log2= Logger.getLogger(Foo.class.getName());
}

     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.ExceptionAsFlowControl" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#ExceptionAsFlowControl" message="Avoid using exceptions as flow control." name="ExceptionAsFlowControl" since="1.8" typeResolution="true">
      <description>
          Using Exceptions as flow control leads to GOTOish code and obscures true exceptions when debugging.
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
public class Foo {
 void bar() {
  try {
   try {
   } catch (Exception e) {
    throw new WrapperException(e);
    // this is essentially a GOTO to the WrapperException catch block
   }
  } catch (WrapperException e) {
   // do some more stuff
  }
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#DoNotExtendJavaLangError" message="Exceptions should not extend java.lang.Error" name="DoNotExtendJavaLangError" since="4.0" typeResolution="true">
      <description>
      [
        Errors are system exceptions. Do not extend them.
      
    </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
          
//ClassOrInterfaceDeclaration/ExtendsList/ClassOrInterfaceType
  [@Image="Error" or @Image="java.lang.Error"]
          
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        public class Foo extends Error { }
    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.MethodWithSameNameAsEnclosingClass" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#MethodWithSameNameAsEnclosingClass" message="Classes should not have non-constructor methods with the same name as the class" name="MethodWithSameNameAsEnclosingClass" since="1.5" typeResolution="true">
      <description>
Non-constructor methods should not have the same name as the enclosing class.
       </description>
      <priority>5</priority>
      <example><![CDATA[
    
public class MyClass {
 // this is bad because it is a method
 public void MyClass() {}
 // this is OK because it is a constructor
 public MyClass() {}
}
    
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.NonThreadSafeSingleton" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonThreadSafeSingleton" message="Singleton is not thread safe" name="NonThreadSafeSingleton" since="3.4" typeResolution="true">
      <description>
Non-thread safe singletons can result in bad state changes. Eliminate
static singletons if possible by instantiating the object directly. Static
singletons are usually not needed as only a single instance exists anyway.
Other possible fixes are to synchronize the entire method or to use an
initialize-on-demand holder class (do not use the double-check idiom).

See Effective Java, item 48.
        </description>
      <priority>5</priority>
      <properties>
         <property name="checkNonStaticFields" value="false"/>
         <property name="checkNonStaticMethods" value="true"/>
      </properties>
      <example><![CDATA[
private static Foo foo = null;

//multiple simultaneous callers may see partially initialized objects
public static Foo getFoo() {
    if (foo==null)
        foo = new Foo();
    return foo;
}
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#InstantiationToGetClass" message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead" name="InstantiationToGetClass" since="2.0" typeResolution="true">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 // Replace this
 Class c = new String().getClass();
 // with this:
 Class c = String.class;
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BrokenNullCheck" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BrokenNullCheck" message="Method call on object which may be null" name="BrokenNullCheck" since="3.8" typeResolution="true">
      <description>
The null check is broken since it will throw a NullPointerException itself.
It is likely that you used || instead of &amp;&amp; or vice versa.
     </description>
      <priority>5</priority>
      <example><![CDATA[

class Foo {
 String bar(String string) {
  // should be &&
  if (string!=null || !string.equals(""))
    return string;
  // should be ||
  if (string==null && string.equals(""))
    return string;
 }
}
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#MisplacedNullCheck" message="The null check here is misplaced; if the variable is null there'll be a NullPointerException" name="MisplacedNullCheck" since="3.5" typeResolution="true">
      <description>
    The null check here is misplaced. if the variable is null you'll get a NullPointerException.
    Either the check is useless (the variable will never be "null") or it's incorrect.
      </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//Expression
    /*[self::ConditionalOrExpression or self::ConditionalAndExpression]
     /descendant::PrimaryExpression/PrimaryPrefix
      /Name[starts-with(@Image,
      concat(ancestor::PrimaryExpression/following-sibling::EqualityExpression
       [./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
     /PrimaryExpression/PrimaryPrefix
      /Name[count(../../PrimarySuffix)=0]/@Image,"."))
    ]
    
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 void bar() {
  if (a.equals(baz) && a != null) {}
 }
}
    
      ]]></example>
      <example><![CDATA[
public class Foo {
 void bar() {
  if (a.equals(baz) || a == null) {}
 }
}
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EqualsNull" message="Avoid using equals() to compare against null" name="EqualsNull" since="1.9" typeResolution="true">
      <description>
Inexperienced programmers sometimes confuse comparison concepts
and use equals() to compare to null.
        </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//PrimaryExpression
 [
PrimaryPrefix/Name[ends-with(@Image, 'equals')]
or
PrimarySuffix[ends-with(@Image, 'equals')]
]
[PrimarySuffix/Arguments/ArgumentList[count(Expression)=1]
  /Expression/PrimaryExpression/PrimaryPrefix
   /Literal/NullLiteral]
    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
       
class Bar {
   void foo() {
       String x = "foo";
       if (x.equals(null)) { // bad!
        doSomething();
       }
   }
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.CompareObjectsWithEquals" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#CompareObjectsWithEquals" message="Use equals() to compare object references." name="CompareObjectsWithEquals" since="3.2" typeResolution="true">
      <description>
 Use equals() to compare object references; avoid comparing them with ==.
  </description>
      <priority>4</priority>
      <example><![CDATA[

class Foo {
 boolean bar(String a, String b) {
  return a == b;
 }
}


  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#BadComparison" message="Avoid equality comparisons with Double.NaN" name="BadComparison" since="1.8" typeResolution="true">
      <description>
Avoid equality comparisons with Double.NaN - these are likely to be logic errors.
      </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 boolean x = (y == Double.NaN);
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#JumbledIncrementer" message="Avoid modifying an outer loop incrementer in an inner loop for update expression" name="JumbledIncrementer" since="1.0" typeResolution="true">
      <description>
Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.
     </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
 
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
 
public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
 
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ClassCastExceptionWithToArray" message="This usage of the Collection.toArray() method will throw a ClassCastException." name="ClassCastExceptionWithToArray" since="3.4" typeResolution="true">
      <description>
if you need to get an array of a class from your Collection,
you should pass an array of the desidered class
as the parameter of the toArray method. Otherwise you will get a
ClassCastException.
  </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//CastExpression[Type/ReferenceType/ClassOrInterfaceType[@Image !=
"Object"]]//PrimaryExpression
[
 PrimaryPrefix/Name[ends-with(@Image, '.toArray')]
 and
 PrimarySuffix/Arguments[count(*) = 0]
and
count(PrimarySuffix) = 1
]

    ]]></value>
         </property>
      </properties>
      <example><![CDATA[

import java.util.ArrayList;
import java.util.Collection;

public class Test {

    public static void main(String[] args) {
        Collection c=new ArrayList();
        Integer obj=new Integer(1);
        c.add(obj);

        // this would trigger the rule (and throw a ClassCastException
if executed)
        Integer[] a=(Integer [])c.toArray();

        // this wouldn't trigger the rule
        Integer[] b=(Integer [])c.toArray(new Integer[c.size()]);
    }
}

  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.typeresolution.rules.LooseCoupling" dfa="false" externalInfoUrl="" message="Avoid using implementation types like ''{0}''; use the interface instead" name="LooseCoupling" typeResolution="true">
      <description>&#13;
Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead&#13;
      </description>
      <priority>5</priority>
      <example><![CDATA[

import java.util.ArrayList;
import java.util.HashSet;
public class Bar {
 // Use List instead
 private ArrayList list = new ArrayList();
 // Use Set instead
 public HashSet getFoo() {
  return new HashSet();
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.typeresolution.rules.CloneMethodMustImplementCloneable" dfa="false" externalInfoUrl="" message="clone() method should be implemented only if implementing Cloneable interface" name="CloneMethodMustImplementCloneable" typeResolution="true">
      <description>
The method clone() should only be implemented if the class implements the 
Cloneable interface with the exception of a final method that only throws 
CloneNotSupportedException. This version uses PMD's type resolution facilities, 
and can detect if the class implements or extends a Cloneable class
        </description>
      <priority>5</priority>
      <example><![CDATA[
            
public class MyClass {
 public Object clone() throws CloneNotSupportedException {
  return foo;
 }
}
   
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.sunsecure.MethodReturnsInternalArray" dfa="false" externalInfoUrl="" message="Returning ''{0}'' may expose an internal array." name="MethodReturnsInternalArray" typeResolution="true">
      <description>
Exposing internal arrays directly allows the user to modify some code that could be critical.
It is safer to return a copy of the array.
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
public class SecureSystem {
  UserData [] ud;
  public UserData [] getUserData() {
      // Don't return directly the internal array, return a copy
      return ud;
  }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="clone() method should throw CloneNotSupportedException" name="CloneThrowsCloneNotSupportedException" typeResolution="true">
      <description>
The method clone() should throw a CloneNotSupportedException.
         </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                     
//MethodDeclaration
[
MethodDeclarator/@Image = 'clone'
and count(MethodDeclarator/FormalParameters/*) = 0
and count(NameList/Name[contains
(@Image,'CloneNotSupportedException')]) = 0
]
[
../../../../ClassOrInterfaceDeclaration[@Final = 'false']
]
                     
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
             
 public class MyClass implements Cloneable{
     public Object clone() { // will cause an error
          MyClass clone = (MyClass)super.clone();
          return clone;
     }
 }
    
         ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule" dfa="false" externalInfoUrl="" message="TOTE_ATTRIBUTE: Avoid unused private fields such as ''{0}''." name="UnusedPrivateField" typeResolution="true">
      <description>Detects when a private field is declared and/or assigned a value, but not used.</description>
      <priority>3</priority>
      <example><![CDATA[public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedLocalVariableRule" dfa="false" externalInfoUrl="" message="Avoid unused local variables such as ''{0}''." name="UnusedLocalVariable" typeResolution="true">
      <description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 public void doSomething() {
  int i = 5; // Unused
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule" dfa="false" externalInfoUrl="" message="TOTE_METHODEN: Avoid unused private methods such as ''{0}''." name="UnusedPrivateMethod" typeResolution="true">
      <description>Unused Private Method detects when a private method is declared but is unused.</description>
      <priority>3</priority>
      <example><![CDATA[public class Something {
 private void foo() {} // unused
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedFormalParameterRule" dfa="false" externalInfoUrl="" message="TOTE_PARAMETER: Avoid unused {0} parameters such as ''{1}''." name="UnusedFormalParameter" typeResolution="true">
      <description>Avoid passing parameters to methods or constructors and then not using those parameters.</description>
      <priority>3</priority>
      <example><![CDATA[public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.StringToStringRule" dfa="false" externalInfoUrl="" message="Avoid calling toString() on String objects; this is unnecessary." name="StringToString" typeResolution="true">
      <description>&#13;
    Avoid calling toString() on String objects; this is unnecessary.&#13;
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.InefficientStringBuffering" dfa="false" externalInfoUrl="" message="Avoid concatenating nonliterals in a StringBuffer constructor or append()." name="InefficientStringBuffering" typeResolution="true">
      <description>
Avoid concatenating non literals in a StringBuffer constructor or append().
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 void bar() {
  // Avoid this
  StringBuffer sb=new StringBuffer("tmp = "+System.getProperty("java.io.tmpdir"));
  // use instead something like this
  StringBuffer sb = new StringBuffer("tmp = ");
  sb.append(System.getProperty("java.io.tmpdir"));
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.UnnecessaryCaseChange" dfa="false" externalInfoUrl="" message="STRING_VERGLEICH_CASING: Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()." name="UnnecessaryCaseChange" typeResolution="true">
      <description>Using equalsIgnoreCase() is faster than using toUpperCase/toLowerCase().equals()</description>
      <priority>3</priority>
      <example><![CDATA[public class Foo {
  public boolean bar(String buz) {
    // should be buz.equalsIgnoreCase("baz")
    return buz.toUpperCase().equals("baz");
    // another unnecessary toUpperCase()
    // return buz.toUpperCase().equalsIgnoreCase("baz");
  }
 }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.UseStringBufferLength" dfa="false" externalInfoUrl="" message="This is an inefficient use of StringBuffer.toString; call StringBuffer.length instead." name="UseStringBufferLength" typeResolution="true">
      <description>
 Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("")
          or StringBuffer.toString().length() ==.
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
public class Foo {
 void bar() {
  StringBuffer sb = new StringBuffer();
  // this is bad
  if(sb.toString().equals("")) {}
  // this is good
  if(sb.length() == 0) {}
 }
}

  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.AppendCharacterWithChar" dfa="false" externalInfoUrl="" message="Avoid appending characters as strings in StringBuffer.append." name="AppendCharacterWithChar" typeResolution="true">
      <description>
Avoid concatenating characters as strings in StringBuffer.append.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 void bar() {
  StringBuffer sb=new StringBuffer();
  // Avoid this
  sb.append("a");

  // use instead something like this
  StringBuffer sb=new StringBuffer();
  sb.append('a');
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.UseIndexOfChar" dfa="false" externalInfoUrl="" message="String.indexOf(char) is faster than String.indexOf(String)." name="UseIndexOfChar" typeResolution="true">
      <description>
Use String.indexOf(char) when checking for the index of a single character; it executes faster.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 void bar() {
  String s = "hello world";
  // avoid this
  if (s.indexOf("d") {}
  // instead do this
  if (s.indexOf('d') {}
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.InefficientEmptyStringCheck" dfa="false" externalInfoUrl="" message="String.trim().length()==0 is an inefficient way to validate an empty String." name="InefficientEmptyStringCheck" typeResolution="true">
      <description>
String.trim().length() is an inefficient way to check if a String is really empty, as it 
creates a new String object just to check its size. Consider creating a static function that
loops through a string, checking Character.isWhitespace() on each character and returning
false if a non-whitespace character is found.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
    void bar(String string) {
        if (string != null && string.trim().size() > 0) { 
		    doSomething();
        } 
    }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.InsufficientStringBufferDeclaration" dfa="false" externalInfoUrl="" message="StringBuffer constructor is initialized with size {0}, but has at least {1} characters appended." name="InsufficientStringBufferDeclaration" typeResolution="true">
      <description>
Failing to pre-size a StringBuffer properly could cause it to re-size many times 
during runtime. This rule checks the characters that are actually passed into
StringBuffer.append(), but represents a best guess "worst case" scenario. An 
empty StringBuffer constructor initializes the object to 16 characters. This default 
is assumed if the length of the constructor can not be determined.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
    void bar() {
        StringBuffer bad = new StringBuffer();
        bad.append("This is a long string, will exceed the default 16 characters");//bad 
        StringBuffer good = new StringBuffer(41);
        good.append("This is a long string, which is pre-sized");//good
    }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.UselessStringValueOf" dfa="false" externalInfoUrl="" message="No need to call String.valueOf to append to a string." name="UselessStringValueOf" typeResolution="true">
      <description>
No need to call String.valueOf to append to a string; just use the valueOf() argument directly.
      </description>
      <priority>5</priority>
      <example><![CDATA[

public String convert(int i) {
  String s;
  s = "a" + String.valueOf(i); // Bad
  s = "a" + i; // Better
  return s;
}

          ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Do not instantiate a StringBuffer with a char" name="StringBufferInstantiationWithChar" typeResolution="true">
      <description>
StringBuffer sb = new StringBuffer('c'); The
char will be converted into int to intialize
StringBuffer size.
    </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//AllocationExpression/ClassOrInterfaceType
[@Image='StringBuffer']
/../Arguments/ArgumentList/Expression/PrimaryExpression
/PrimaryPrefix/
Literal
  [starts-with(@Image, "'")]
  [ends-with(@Image, "'")]

            ]]></value>
         </property>
      </properties>
      <example><![CDATA[

class Foo {
  StringBuffer sb1 = new StringBuffer('c'); //Bad
  StringBuffer sb2 = new StringBuffer("c"); //Better
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="The Logger variable declaration does not contain the static and final modifiers" name="LoggerIsNotStaticFinal" typeResolution="true">
      <description>
In most cases, the Logger can be declared static and final.
     </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                 
//VariableDeclarator
 [parent::FieldDeclaration]
 [../Type/ReferenceType
  /ClassOrInterfaceType[@Image='Logger']
   and
  (..[@Final='false'] or ..[@Static = 'false'] ) ]
                
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
 
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is much better to declare the logger as follows 
    // static final Logger log = Logger.getLogger(Foo.class.getName());
}

     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid printStackTrace(); use a logger call instead." name="AvoidPrintStackTrace" typeResolution="true">
      <description>
Avoid printStackTrace(); use a logger call instead.
           </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryExpression
 [PrimaryPrefix/Name[contains(@Image,'printStackTrace')]]
 [PrimarySuffix[not(boolean(Arguments/ArgumentList/Expression))]]

             ]]></value>
         </property>
      </properties>
      <example><![CDATA[

class Foo {
 void bar() {
  try {
   // do something
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}

           ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty 'if' statements" name="EmptyIfStmt" typeResolution="true">
      <description>
Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//IfStatement/Statement
 [EmptyStatement or Block[count(*) = 0]]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 void bar(int x) {
  if (x == 0) {
   // empty!
  }
 }
}
 
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty 'while' statements" name="EmptyWhileStmt" typeResolution="true">
      <description>
Empty While Statement finds all instances where a while statement
does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//WhileStatement/Statement[./Block[count(*) = 0]  or ./EmptyStatement]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 void bar(int a, int b) {
  while (a == b) {
   // empty!
  }
 }
}
 
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty try blocks" name="EmptyTryBlock" typeResolution="true">
      <description>
Avoid empty try blocks - what's the point?
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//TryStatement/Block[1][count(*) = 0]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  try {
  } catch (Exception e) {
    e.printStackTrace();
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty finally blocks" name="EmptyFinallyBlock" typeResolution="true">
      <description>
Avoid empty finally blocks - these can be deleted.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//FinallyStatement[count(Block/BlockStatement) = 0]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  try {
    int x=2;
   } finally {
    // empty!
   }
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty switch statements" name="EmptySwitchStatements" typeResolution="true">
      <description>
Avoid empty switch statements.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SwitchStatement[count(*) = 1]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   // once there was code here
   // but it's been commented out or something
  }
 }
}
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This for loop could be simplified to a while loop" name="ForLoopShouldBeWhileLoop" typeResolution="true">
      <description>
Some for loops can be simplified to while loops - this makes them more concise.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//ForStatement
 [count(*) > 1]
 [not(ForInit)]
 [not(ForUpdate)]
 [not(Type and Expression and Statement)]
 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 void bar() {
  for (;true;) true; // No Init or Update part, may as well be: while (true)
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.DoubleCheckedLocking" dfa="false" externalInfoUrl="" message="Double checked locking is not thread safe in Java." name="DoubleCheckedLocking" typeResolution="true">
      <description>
Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
An optimizing JRE may assign a reference to the baz variable before it creates the object the
  reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
public class Foo {
  Object baz;
  Object bar() {
    if(baz == null) { //baz may be non-null yet not fully created
      synchronized(this){
        if(baz == null){
          baz = new Object();
        }
      }
    }
    return baz;
  }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty synchronized blocks" name="EmptySynchronizedBlock" typeResolution="true">
      <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SynchronizedStatement/Block[1][count(*) = 0]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar() {
  synchronized (this) {
   // empty!
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.UnnecessaryReturn" dfa="false" externalInfoUrl="" message="Avoid unnecessary return statements" name="UnnecessaryReturn" typeResolution="true">
      <description>
Avoid unnecessary return statements
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  int x = 42;
  return;
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Empty static initializer was found" name="EmptyStaticInitializer" typeResolution="true">
      <description>
An empty static initializer was found.
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//Initializer[@Static='true']/Block[count(*)=0]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 static {
  // empty
 }
 }

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Do not use 'if' statements that are always true or always false" name="UnconditionalIfStatement" typeResolution="true">
      <description>
Do not use "if" statements that are always true or always false.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An empty statement (semicolon) not part of a loop" name="EmptyStatementNotInLoop" typeResolution="true">
      <description>
An empty statement (aka a semicolon by itself) that is not used
as the sole body of a for loop or while loop is probably a bug.  It
could also be a double semicolon, which is useless and should be
removed.
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//EmptyStatement
 [not(
       ../../../ForStatement
       or ../../../WhileStatement
       or ../../../BlockStatement/ClassOrInterfaceDeclaration
       or ../../../../../../ForStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement
       or ../../../../../../WhileStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement)
 ]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class MyClass {
   public void doit() {
      // this is probably not what you meant to do
      ;
      // the extra semicolon here this is not necessary
      System.out.println("look at the extra semicolon");;
   }
}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BooleanInstantiation" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead." name="BooleanInstantiation" typeResolution="true">
      <description>Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.</description>
      <priority>3</priority>
      <example><![CDATA[public class Foo {
 Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE;
 Boolean buz = Boolean.valueOf(false); // just do a Boolean buz = Boolean.FALSE;
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UselessOperationOnImmutable" dfa="false" externalInfoUrl="" message="An operation on an Immutable object (BigDecimal or BigInteger) won't change the object itself" name="UselessOperationOnImmutable" typeResolution="true">
      <description>
    An operation on an Immutable object (BigDecimal or BigInteger) won't change the object itself. The
    result of the operation is a new object. Therefore, ignoring the operation result is an error.
      </description>
      <priority>5</priority>
      <example><![CDATA[
    
import java.math.*;
class Test {
 void method1() {
  BigDecimal bd=new BigDecimal(10);
  bd.add(new BigDecimal(5)); // this will trigger the rule
 }
 void method2() {
  BigDecimal bd=new BigDecimal(10);
  bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
 }
}
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Invoke equals() on the object you''ve already ensured is not null" name="UnusedNullCheckInEquals" typeResolution="true">
      <description>&#13;
    After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.&#13;
    </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
        
//PrimarySuffix[@Image='equals' and not(../PrimaryPrefix/Literal)]
 /../PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image = ./../../../../../../../../../../Expression/ConditionalAndExpression
 /EqualityExpression[@Image="!=" and count(./preceding-sibling::*)=0 and
 ./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
  /PrimaryExpression/PrimaryPrefix/Name/@Image]
        
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Test {

public String method1() { return "ok";}
public String method2() { return null;}

public void method(String a) {
String b;
/*
I don't know it method1() can be "null"
but I know "a" is not null..
I'd better write a.equals(method1())
*/
if (a!=null && method1().equals(a)) { // will
trigger the rule
//whatever
}

if (method1().equals(a) && a != null) { //
won't trigger the rule
//whatever
}

if (a!=null && method1().equals(b)) { // won't
trigger the rule
//whatever
}

if (a!=null && "LITERAL".equals(a)) { // won't
trigger the rule
//whatever
}

if (a!=null && !a.equals("go")) { // won't
trigger the rule
a=method2();
if (method1().equals(a)) {
//whatever
}
}
}
}

]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BigIntegerInstantiation" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Don't create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN)" name="BigIntegerInstantiation" typeResolution="true">
      <description>Don't create instances of already existing BigInteger&#13;
(BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,&#13;
BigInteger.TEN and BigDecimal (BigDecimal.ZERO,&#13;
BigDecimal.ONE, BigDecimal.TEN)</description>
      <priority>3</priority>
      <example><![CDATA[public class Test {

 public static void main(String[] args) {
   BigInteger bi=new BigInteger(1);
   BigInteger bi2=new BigInteger("0");
   BigInteger bi3=new BigInteger(0.0);
   BigInteger bi4;
   bi4=new BigInteger(0);
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.AvoidUsingOctalValues" dfa="false" externalInfoUrl="" message="Do not start a literal by 0 unless it's an octal value" name="AvoidUsingOctalValues" typeResolution="true">
      <description>&#13;
    	&#13;
		    Integer literals should not start with zero.&#13;
		    Zero means that the rest of literal will be interpreted as an octal value.&#13;
    	&#13;
    </description>
      <priority>5</priority>
      <example><![CDATA[
		    
		public class Foo {
		  int i = 012; // set i with 10 not 12
		  int j = 010; // set j with 8 not 10
		  k = i * j; // set k with 80 not 120
		}
		    
    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.AvoidUsingHardCodedIP" dfa="false" externalInfoUrl="" message="Do not hard code IPv4 or IPv6 addresses, even 127.0.0.1 !" name="AvoidUsingHardCodedIP" typeResolution="true">
      <description>
	    	
				An application with hard coded IP may become impossible to deploy in some case. It never hurts
				to externalize IP adresses.
	    	
	    </description>
      <priority>5</priority>
      <properties>
         <property name="pattern" value="^&quot;[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}&quot;$"/>
      </properties>
      <example><![CDATA[
	    
	public class Foo {
	  String ip = "127.0.0.1"; // This is a really bad idea !
	}
	    
	    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet." name="CheckResultSet" typeResolution="true">
      <description>
            
	            Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet. Indeed,
	            if the value return is 'false', the developer should deal with it !
            
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
		        	
//Type/ReferenceType/ClassOrInterfaceType[
	(@Image = 'ResultSet')
	and
	(../../../descendant::Name[ends-with(@Image,'executeQuery')])
	and
	(
		not (contains(
			(./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
			(concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.next') )
		))
		and
		not (contains(
			(./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
			(concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.previous') )
		) )
		and
		not (contains(
			(./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
			(concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.first') )
		) )
		and
		not (contains(
			(./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
			(concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.last') )
		) )
	)
]
		        	
            	]]></value>
         </property>
      </properties>
      <example><![CDATA[
            [
            // This is NOT appropriate !
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            rst.next(); // what if it returns a 'false' ?
            String firstName = rst.getString(1);

            // This is appropriate...
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            if (rst.next())
            {
                String firstName = rst.getString(1);
            }
            else
            {
                // here you deal with the error ( at least log it)
            }
            
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Logger should be defined private static final and have the correct class" name="ProperLogger" typeResolution="true">
      <description>&#13;
A logger should normally be defined private static final and have the correct class.&#13;
Private final Log log; is also allowed for rare cases where loggers need to be passed&#13;
around, with the restriction that the logger needs to be passed into the constructor.&#13;
             </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
     
//ClassOrInterfaceBodyDeclaration[FieldDeclaration//ClassOrInterfaceType[@Image='Log']
 and
 not(FieldDeclaration[@Final='true'][@Static='true'][@Private='true'][.//VariableDeclaratorId[@Image=$staticLoggerName]]
 //ArgumentList//ClassOrInterfaceType/@Image = ancestor::ClassOrInterfaceDeclaration/@Image)
 and
 not(FieldDeclaration[@Final='true'][@Private='true'][.//VariableDeclaratorId[@Image='log']]
 [count(.//VariableInitializer)=0]
 [ancestor::ClassOrInterfaceBody//StatementExpression[.//PrimaryExpression/descendant::*[@Image='log']][count(.//AllocationExpression)=0]]
 )]
     
                     ]]></value>
         </property>
         <property name="staticLoggerName" value="LOG"/>
      </properties>
      <example><![CDATA[
 
 public class Foo {
 // right
  private static final Log LOG = LogFactory.getLog(Foo.class);
 // wrong
 protected Log LOG = LogFactory.getLog(Testclass.class);
}
 
            ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Classes implementing Serializable should set a serialVersionUID" name="MissingSerialVersionUID" typeResolution="true">
      <description>
Classes that are serializable should provide a serialVersionUID field.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//ClassOrInterfaceDeclaration
 [
  count(ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
   /FieldDeclaration/VariableDeclarator/VariableDeclaratorId[@Image='serialVersionUID']) = 0
and
  count(ImplementsList
   [ClassOrInterfaceType/@Image='Serializable'
   or ClassOrInterfaceType/@Image='java.io.Serializable']) =1
and
   @Abstract = 'false'
]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo implements java.io.Serializable {
 String name;
 // Define serialization id to avoid serialization related bugs
 // i.e., public static final long serialVersionUID = 4328743;
}


          ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.naming.SuspiciousHashcodeMethodName" dfa="false" externalInfoUrl="" message="The method name and return type are suspiciously close to hashCode()" name="SuspiciousHashcodeMethodName" typeResolution="true">
      <description>
The method name and return type are suspiciously close to hashCode(), which
may mean you are intending to override the hashCode() method.
       </description>
      <priority>5</priority>
      <example><![CDATA[
    
public class Foo {
 public int hashcode() {
 // oops, this probably was supposed to be hashCode
 }
}
    
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="KONSTANTHEIT_VERSTECKTE: The field name indicates a constant but its modifiers do not" name="SuspiciousConstantFieldName" typeResolution="true">
      <description>A field name is all in uppercase characters, which in Sun's Java naming&#13;
conventions indicate a constant. However, the field is not final.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
 
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
 // this is bad, since someone could accidentally
 // do PI = 2.71828; which is actualy e
 // final double PI = 3.16; is ok
 double PI = 3.16;
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="The method name and parameter number are suspiciously close to equals(Object)" name="SuspiciousEqualsMethodName" typeResolution="true">
      <description>
The method name and parameter number are suspiciously close to
equals(Object), which may mean you are intending to override the equals(Object)
method.
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
        
//MethodDeclarator[
(
@Image = 'equals'
  and count(FormalParameters/*) = 1
  and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
   [@Image = 'Object' or @Image = 'java.lang.Object'])
)
or
@Image='equal'
 and count(FormalParameters/*) = 1
 and (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
  [@Image = 'Object' or @Image = 'java.lang.Object'])

]
        
                    ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        
public class Foo {
 public int equals(Object o) {
 // oops, this probably was supposed to be boolean equals
 }
 public boolean equals(String s) {
 // oops, this probably was supposed to be equals(Object)
 }
}
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidFieldNameMatchingTypeName" dfa="false" externalInfoUrl="" message="It is somewhat confusing to have a field name matching the declaring class name" name="AvoidFieldNameMatchingTypeName" typeResolution="true">
      <description>
It is somewhat confusing to have a field name matching the declaring class name.
This probably means that type and or field names could be more precise.
      </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo extends Bar {
 // There's probably a better name for foo
 int foo;
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidFieldNameMatchingMethodName" dfa="false" externalInfoUrl="" message="It is somewhat confusing to have a field name with the same name as a method" name="AvoidFieldNameMatchingMethodName" typeResolution="true">
      <description>
It is somewhat confusing to have a field name with the same name as a method.
While this is totally legal, having information (field) and actions (method) is
not clear naming.
      </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
	Object bar;
	// bar is data or an action or both?
	void bar() {
	}
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UseSingleton" dfa="false" externalInfoUrl="" message="All methods are static.  Consider using Singleton instead.  Alternatively, you could add a private constructor or make the class abstract to silence this warning." name="UseSingleton" typeResolution="true">
      <description>
If you have a class that has nothing but static methods, consider making it a Singleton.
Note that this doesn't apply to abstract classes, since their subclasses may
well include non-static methods.  Also, if you want this class to be a Singleton,
remember to add a private constructor to prevent instantiation.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class MaybeASingleton {
 public static void foo() {}
 public static void bar() {}
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.SimplifyBooleanReturns" dfa="false" externalInfoUrl="" message="Avoid unnecessary if..then..else statements when returning a boolean" name="SimplifyBooleanReturns" typeResolution="true">
      <description>
Avoid unnecessary if..then..else statements when returning a boolean.
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid unnecessary comparisons in boolean expressions" name="SimplifyBooleanExpressions" typeResolution="true">
      <description>
Avoid unnecessary comparisons in boolean expressions - this complicates simple code.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//EqualityExpression/PrimaryExpression
 /PrimaryPrefix/Literal/BooleanLiteral

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod" dfa="false" externalInfoUrl="" message="KONSTRUKTOR_RUFT_VIRT_METHODE: Overridable {0} called during object construction" name="ConstructorCallsOverridableMethod" typeResolution="true">
      <description>Calling overridable methods during construction poses a risk of invoking methods on an&#13;
incompletely constructed object and can be difficult to discern.&#13;
It may leave the sub-class unable to construct its superclass or forced to&#13;
replicate the construction process completely within itself, losing the ability to call&#13;
super().  If the default constructor contains a call to an overridable method,&#13;
the subclass may be completely uninstantiable.   Note that this includes method calls&#13;
throughout the control flow graph - i.e., if a constructor Foo() calls a private method&#13;
bar() that calls a public method buz(), this denotes a problem.</description>
      <priority>3</priority>
      <example><![CDATA[public class SeniorClass {
  public SeniorClass(){
      toString(); //may throw NullPointerException if overridden
  }
  public String toString(){
    return "IAmSeniorClass";
  }
}
public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass(){
    super(); //Automatic call leads to NullPointerException
    name = "JuniorClass";
  }
  public String toString(){
    return name.toUpperCase();
  }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="KONSTANTHEIT_NICHT_STATISCHE: This final field could be made static" name="FinalFieldCouldBeStatic" typeResolution="true">
      <description>If a final field is assigned to a compile-time constant, it could be&#13;
made static, thus saving overhead in each object at runtime.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
 public final int BAR = 42; // this could be static and save some space
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.CloseResource" dfa="false" externalInfoUrl="" message="RESSOURCEN_SCHLIESSEN: Ensure that resources like this {0} object are closed after use" name="CloseResource" typeResolution="true">
      <description>Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.</description>
      <priority>3</priority>
      <properties>
         <property name="types" value="Connection,Statement,ResultSet"/>
      </properties>
      <example><![CDATA[public class Bar {
 public void foo() {
  Connection c = pool.getConnection();
  try {
    // do stuff
  } catch (SQLException ex) {
    // handle exception
  } finally {
    // oops, should close the connection using 'close'!
    // c.close();
  }
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This call to Collection.toArray() may be optimizable" name="OptimizableToArrayCall" typeResolution="true">
      <description>
A call to Collection.toArray can use the Collection's size vs an empty Array of the desired type.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]

                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
class Foo {
 void bar(Collection x) {
   // A bit inefficient
   x.toArray(new Foo[0]);
   // Much better; this one sizes the destination array, avoiding
   // a reflection call in some Collection implementations
   x.toArray(new Foo[x.size()]);
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.IdempotentOperations" dfa="false" externalInfoUrl="" message="Avoid idempotent operations (like assigning a variable to itself)." name="IdempotentOperations" typeResolution="true">
      <description>
Avoid idempotent operations - they are have no effect.
      </description>
      <priority>5</priority>
      <example><![CDATA[
      
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
      
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="When instantiating a SimpleDateFormat object, specify a Locale" name="SimpleDateFormatNeedsLocale" typeResolution="true">
      <description>
Be sure to specify a Locale when creating a new instance of SimpleDateFormat.
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//AllocationExpression
 [ClassOrInterfaceType[@Image='SimpleDateFormat']]
 [Arguments[@ArgumentCount=1]]

                    ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        
public class Foo {
 // Should specify Locale.US (or whatever)
 private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
}
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.ImmutableField" dfa="false" externalInfoUrl="" message="KONSTANTHEIT_VERSTECKTE: Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor." name="ImmutableField" typeResolution="true">
      <description>Identifies private fields whose values never change once they are initialized either in the declaration of the field or by&#13;
a constructor.  This aids in converting existing classes to immutable classes.</description>
      <priority>3</priority>
      <example><![CDATA[public class Foo {
  private int x; // could be final
  public Foo() {
      x = 7;
  }
  public void foo() {
     int a = x + 2;
  }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid protected fields in a final class.  Change to private or package access." name="AvoidProtectedFieldInFinalClass" typeResolution="true">
      <description>
Do not use protected fields in final classes since they cannot be subclassed.
Clarify your intent by using private or package access modifiers instead.
         </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//ClassOrInterfaceDeclaration[@Final='true']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected='true']
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public final class Bar {
 private int x;
 protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
 Bar() {}
}
 
         ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.AssignmentToNonFinalStatic" dfa="false" externalInfoUrl="" message="Possible unsafe assignment to a non-final static field in a constructor." name="AssignmentToNonFinalStatic" typeResolution="true">
      <description>
Identifies a possible unsafe usage of a static field.
       </description>
      <priority>5</priority>
      <example><![CDATA[
   
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Class cannot be instantiated and does not provide any static methods or fields" name="MissingStaticMethodInNonInstantiatableClass" typeResolution="true">
      <description>
A class that has private constructors and does not have any static methods or fields cannot be used.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//ClassOrInterfaceDeclaration[@Nested='false'][
( count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)>0
  and count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) = count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private='true']) )
and
count(.//MethodDeclaration[@Static='true'])=0
and
count(.//FieldDeclaration[@Private='false'][@Static='true'])=0
]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

/* This class is unusable, since it cannot be
 instantiated (private constructor),
 and no static method can be called.
 */
public class Foo {
 private Foo() {}
 void foo() {}
}


      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="SYNCHRONISATION: Use block level rather than method level synchronization" name="AvoidSynchronizedAtMethodLevel" typeResolution="true">
      <description>Method level synchronization can backfire when new code is added to the method.  Block-level&#13;
  synchronization helps to ensure that only the code that needs synchronization gets it.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//MethodDeclaration[@Synchronized='true']
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
 // Try to avoid this
 synchronized void foo() {
 }
 // Prefer this:
 void bar() {
  synchronized(this) {
  }
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Call Thread.notifyAll() rather than Thread.notify()" name="UseNotifyAllInsteadOfNotify" typeResolution="true">
      <description>
Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
one is chosen.  The thread chosen is arbitrary; thus it's usually safer to call notifyAll() instead.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//StatementExpression/PrimaryExpression
[count(PrimarySuffix/Arguments/ArgumentList) = 0]
[
PrimaryPrefix[./Name[@Image='notify' or ends-with(@Image,'.notify')]
or @Image='notify'
or (./AllocationExpression and ../PrimarySuffix[@Image='notify'])
]
]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 void bar() {
  x.notify();
  // If many threads are monitoring x, only one (and you won't know which) will be notified.
  // use instead:
  x.notifyAll();
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type." name="AvoidInstanceofChecksInCatchClause" typeResolution="true">
      <description>
Each caught exception type should be handled in its own catch clause.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

try { // Avoid this
 // do something
} catch (Exception ee) {
 if (ee instanceof IOException) {
  cleanup();
 }
}
try {  // Prefer this:
 // do something
} catch (IOException ee) {
 cleanup();
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This abstract class does not have any abstract methods" name="AbstractClassWithoutAbstractMethod" typeResolution="true">
      <description>
The abstract class does not contain any abstract methods. An abstract class suggests
an incomplete implementation, which is to be completed by subclasses implementing the
abstract methods. If the class is intended to be used as a base class only (not to be instantiated
direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
  [count(.//ExtendsList)=0]
              
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public abstract class Foo {
 void int method1() { ... }
 void int method2() { ... }
 // consider using abstract methods or removing
 // the abstract modifier and adding protected constructors
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="No need to check for null before an instanceof" name="SimplifyConditional" typeResolution="true">
      <description>&#13;
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.&#13;
          </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                      
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      /PrimaryExpression/PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression/PrimaryExpression/PrimaryPrefix/Name/@Image]]]
 
                  ]]></value>
         </property>
      </properties>
      <example><![CDATA[
      
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      
           ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Position literals first in String comparisons" name="PositionLiteralsFirstInComparisons" typeResolution="true">
      <description>
 Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false.
  </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
              
//PrimaryExpression[
	PrimaryPrefix[Name
		[ends-with(@Image, '.equals')]
		]
	[../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal]
]
[not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
[not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]
          
          ]]></value>
         </property>
      </properties>
      <example><![CDATA[

class Foo {
 boolean bar(String x) {
  return x.equals("2"); // should be "2".equals(x)
 }
}


  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UnnecessaryLocalBeforeReturn" dfa="false" externalInfoUrl="" message="Consider simply returning the value vs storing it in local variable ''{0}''" name="UnnecessaryLocalBeforeReturn" typeResolution="true">
      <description>
Avoid unnecessarily creating local variables
      </description>
      <priority>5</priority>
      <example><![CDATA[
  
  public class Foo {
    public int foo() {
      int x = doSomething();
      return x;  // instead, just 'return doSomething();'
    }
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.PreserveStackTrace" dfa="false" externalInfoUrl="" message="EXCEPTIONS_WEITERLEITEN: Caught exception is rethrown, original stack trace may be lost" name="PreserveStackTrace" typeResolution="true">
      <description>Throwing a new exception from a catch block without passing the original exception into the&#13;
new Exception will cause the true stack trace to be lost, and can make it difficult to&#13;
debug effectively.</description>
      <priority>3</priority>
      <example><![CDATA[public class Foo {
    void good() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e);
        }
    }
    void bad() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e.getMessage());
        }
    }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UseCollectionIsEmpty" dfa="false" externalInfoUrl="" message="Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()" name="UseCollectionIsEmpty" typeResolution="true">
      <description>
The isEmpty() method on java.util.Collection is provided to see if a collection has any elements.
Comparing the value of size() to 0 merely duplicates existing behavior.
      </description>
      <priority>5</priority>
      <example><![CDATA[
    
	public class Foo {
		void good() {
        	List foo = getList();
			if (foo.isEmpty()) {
				// blah
			}
    	}

	    void bad() {
    	    List foo = getList();
				if (foo.size() == 0) {
					// blah
				}
	    	}
	}
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="A class which only has private constructors should be final" name="ClassWithOnlyPrivateConstructorsShouldBeFinal" typeResolution="true">
      <description>
A class with only private constructors should be final, unless the private 
constructor is called by a inner class.
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
TypeDeclaration[count(../TypeDeclaration) = 1]/ClassOrInterfaceDeclaration
[@Final = 'false']
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private = 'true']) >= 1 ]
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Public = 'true'])  = 0 ]
[not(.//ClassOrInterfaceDeclaration)]
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
public class Foo {  //Should be final
    private Foo() { }
}
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An empty method in an abstract class should be abstract instead" name="EmptyMethodInAbstractClassShouldBeAbstract" typeResolution="true">
      <description>
An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation
rather than code the appropriate one.
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
                    //ClassOrInterfaceDeclaration[@Abstract = 'true']
                        /ClassOrInterfaceBody
                        /ClassOrInterfaceBodyDeclaration
                        /MethodDeclaration[@Abstract = 'false']
                        [
                            ( boolean(./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression) = 'true' )
                            or
                            ( count (./Block/*) = 0 )
                        ]
                
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        	
				public abstract class ShouldBeAbstract
				{
				    public Object couldBeAbstract()
				    {
					// Should be abstract method ?
					return null;
				   	}

				    public void couldBeAbstract()
				    {
				    }
				}
	     	
    	]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.SingularField" dfa="false" externalInfoUrl="" message="Perhaps ''{0}'' could be replaced by a local variable." name="SingularField" typeResolution="true">
      <description>
This field is used in only one method and the first usage is assigning a value 
to the field. This probably means that the field can be changed to a local variable.
      </description>
      <priority>5</priority>
      <properties>
         <property name="DisallowNotAssignment" value="false"/>
         <property name="CheckInnerClasses" value="false"/>
      </properties>
      <example><![CDATA[
public class Foo {
    private int x;  //Why bother saving this?
    public void foo(int y) {
     x = y + 5;
     return x;
    }
}
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty finalize methods" name="EmptyFinalizer" typeResolution="true">
      <description>
If the finalize() method is empty, then it does not need to exist.
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
  /Block[count(*)=0]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
   protected void finalize() {}
}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Finalize should do something besides just calling super.finalize()" name="FinalizeOnlyCallsSuperFinalize" typeResolution="true">
      <description>
If the finalize() is implemented, it should do something besides just calling
super.finalize().
       </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration[MethodDeclarator[@Image="finalize"][not(FormalParameters/*)]]
   /Block[count(BlockStatement)=1]
     /BlockStatement[
       Statement/StatementExpression/PrimaryExpression
      /PrimaryPrefix[@Image="finalize"]
      ]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
           
public class Foo {
   protected void finalize() {
     super.finalize();
   }
}
           
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Finalize methods should not be overloaded" name="FinalizeOverloaded" typeResolution="true">
      <description>
Methods named finalize() should not have parameters.  It is
confusing and probably a bug to overload finalize().  It will
not be called by the VM.
   </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration
 /MethodDeclarator[@Image='finalize'][FormalParameters[count(*)>0]]

            ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
   // this is confusing and probably a bug
   protected void finalize(int a) {
   }
}

   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="If you override finalize(), make it protected" name="FinalizeShouldBeProtected" typeResolution="true">
      <description>
If you override finalize(), make it protected.  If you make
 it public, other classes may call it.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void finalize() {
  // do something
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidCallingFinalize" dfa="false" externalInfoUrl="" message="Avoid calling finalize() explicitly" name="AvoidCallingFinalize" typeResolution="true">
      <description>
Object.finalize() is called by the garbage collector on an object when garbage collection determines
that there are no more references to the object.
      </description>
      <priority>5</priority>
      <example><![CDATA[

public class Foo {
 void foo() {
  Bar b = new Bar();
  b.finalize();
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.optimization.AvoidInstantiatingObjectsInLoops" dfa="false" externalInfoUrl="" message="Avoid instantiating new objects inside loops" name="AvoidInstantiatingObjectsInLoops" typeResolution="true">
      <description>
Detects when a new object is created inside a loop
    </description>
      <priority>5</priority>
      <example><![CDATA[

public class Something {
  public static void main( String as[] ) {  
    for (int i = 0; i < 10; i++) {
      Foo f = new Foo(); //Avoid this whenever you can it's really expensive
    }
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This call to String.startsWith can be rewritten using String.charAt(0)" name="SimplifyStartsWith" typeResolution="true">
      <description>
Since it passes in a literal of length 1, this call to String.startsWith can be rewritten using String.charAt(0) to save some time.
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryExpression
 [PrimaryPrefix/Name
  [ends-with(@Image, '.startsWith')]]
 [PrimarySuffix/Arguments/ArgumentList
  /Expression/PrimaryExpression/PrimaryPrefix
  /Literal
   [string-length(@Image)=3]
   [starts-with(@Image, '"')]
   [ends-with(@Image, '"')]
 ]
 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
  boolean checkIt(String x) {
      return x.startsWith("a");
  }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Use asList instead of tight loops" name="UseArraysAsList" typeResolution="true">
      <description>
   The class java.util.Arrays has a "asList" method that
   should be use when you want to create a new List from
   an array of objects. It is faster than executing a loop to
   cpy all the elements of the array one by one
     </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
   
//Statement[
    (ForStatement) and (count(.//IfStatement)=0)
   ]
   //StatementExpression[
    PrimaryExpression/PrimaryPrefix/Name[
	 substring-before(@Image,'.add') = ancestor::MethodDeclaration//LocalVariableDeclaration[
      ./Type//ClassOrInterfaceType[
       @Image = 'Collection' or 
       @Image = 'List' or @Image='ArrayList'
      ]
     ]
     /VariableDeclarator/VariableDeclaratorId[
      count(..//AllocationExpression/ClassOrInterfaceType[
       @Image="ArrayList"
      ]
      )=1
     ]/@Image
    ]
   and
   PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
   [@Image = ancestor::MethodDeclaration//LocalVariableDeclaration
   [@Array="true"]/VariableDeclarator/VariableDeclaratorId/@Image]
   /../..[count(.//PrimarySuffix)
   =1]/PrimarySuffix/Expression/PrimaryExpression/PrimaryPrefix
   /Name
   ]
   
       ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
   public class Test {
    public void foo(Integer[] ints) {
    // could just use Arrays.asList(ints)
     List l= new ArrayList(10);
     for (int i=0; i< 100; i++) {
      l.add(ints[i]);
     }
     for (int i=0; i< 100; i++) {
      l.add(a[i].toString()); // won't trigger the rule
     }
    }
   }
   
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="System.arraycopy is more efficient" name="AvoidArrayLoops" typeResolution="true">
      <description>&#13;
    Instead of copying data between two arrays, use&#13;
    System.arraycopy method&#13;
      </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//Statement[(ForStatement or WhileStatement) and
count(*//AssignmentOperator[@Image = '='])=1
and
*/Statement
[
./Block/BlockStatement/Statement/StatementExpression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix/Expression
[(PrimaryExpression or AdditiveExpression) and count
(.//PrimaryPrefix/Name)=1]//PrimaryPrefix/Name/@Image
and
./Block/BlockStatement/Statement/StatementExpression/Expression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix[count
(..//PrimarySuffix)=1]/Expression[(PrimaryExpression
or AdditiveExpression) and count(.//PrimaryPrefix/Name)=1]
//PrimaryPrefix/Name/@Image
]]
    
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Test {
 public void bar() {
  int[] a = new int[10];
  int[] b = new int[10];
  for (int i=0;i<10;i++) {
   b[i]=a[i];
  }
 }
}
            // this will trigger the rule
            for (int i=0;i<10;i++) {
             b[i]=a[c[i]];
            }

        }
    }
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Do not add empty strings" name="AddEmptyString" typeResolution="true">
      <description>&#13;
Finds empty string literals which are being added. This is an inefficient way &#13;
to convert any type to a String.&#13;
        </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                     
//AdditiveExpression/PrimaryExpression/PrimaryPrefix/Literal[@Image='""']
                
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
             
        String s = "" + 123; // bad 
        String t = Integer.toString(456); // ok 
            
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.imports.DontImportSun" dfa="false" externalInfoUrl="" message="Avoid importing anything from the 'sun.*' packages" name="DontImportSun" typeResolution="true">
      <description>
Avoid importing anything from the 'sun.*' packages.  These packages are not portable and are likely to change.
       </description>
      <priority>3</priority>
      <example><![CDATA[

import sun.misc.foo;
public class Foo {}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid using final local variables, turn them into fields" name="AvoidFinalLocalVariable" typeResolution="true">
      <description>
Avoid using final local variables, turn them into fields.
         </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
//LocalVariableDeclaration[@Final = 'true']
	             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
public class MyClass {
    public void foo() {
        final String finalLocalVariable;
    }
}
	     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Do not use the short type" name="AvoidUsingShortType" typeResolution="true">
      <description>
            
            Java uses the short type to reduce memory usage, not to optimize calculation. On the contrary, the jvm does not has an
            arithmetic capabilities with the type short. So, the P-code msut convert the short into int, then do the proper caculation
            and then again, convert int to short. So, use of the 'short' type may have a great effect on memory usage.
            
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
            //PrimitiveType[@Image = 'short']
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
    public class UsingShort
    {
        private short doNotUseShort = 0;

		public UsingShort() {
			short shouldNotBeUsed = 1;
			doNotUseShort += shouldNotBeUsed;
		}
 	}
 			
 		]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Use of modifier volatile is not recommended." name="AvoidUsingVolatile" typeResolution="true">
      <description>&#13;
            &#13;
Use of the keyword 'volatile' is general used to fine tune a Java application, and therefore, requires&#13;
a good expertise of the Java Memory Model. Morover, its range of action is somewhat misknown. Therefore,&#13;
the volatile keyword should not be used for maintenance purpose and portability.&#13;
            &#13;
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
                        //FieldDeclaration[
                                contains(@Volatile,'true')
                        ]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
			
				public class ThrDeux {
					private volatile String var;

				}
			
		]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="The use of native code is not recommended." name="AvoidUsingNativeCode" typeResolution="true">
      <description>&#13;
            &#13;
                As JVM and Java language offer already many help in creating application, it should be&#13;
                very rare to have to rely on non-java code. Even though, it is rare to actually have to&#13;
                use Java Native Interface (JNI). As the use of JNI make application less portable, and&#13;
                harder to maintain, it is not recommended.&#13;
            &#13;
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
                        //Name[starts-with(@Image,'System.loadLibrary')]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
                public class SomeJNIClass {
                        public SomeJNIClass() {
                                System.loadLibrary("nativelib");
                        }

                        static {
                             System.loadLibrary("nativelib");
                        }

                        public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
                                System.loadLibrary("nativelib");
                        }
                }
            
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="You should modify visibility of class or methods using getDeclaredConstructors(), getDeclaredConstructor(Class[]), setAccessible() or PrivilegedAction." name="AvoidAccessibilityAlteration" typeResolution="true">
      <description>
            
            Methods such as getDeclaredConstructors(), getDeclaredConstructor(Class[]) and setAccessible(),
            as the interface PrivilegedAction, allow to alter, at runtime, the visilibilty of variable, classes, or
            methods, even if they are private. Obviously, no one should do so, as such behavior is against everything
            encapsulation principal stands for.
            
        </description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                   
                        //PrimaryExpression[
                        (
                        (PrimarySuffix[
                                ends-with(@Image,'getDeclaredConstructors')
                                        or
                                ends-with(@Image,'getDeclaredConstructor')
                                        or
                                ends-with(@Image,'setAccessible')
                                ])
                        or
                        (PrimaryPrefix/Name[
                                ends-with(@Image,'getDeclaredConstructor')
                                or
                                ends-with(@Image,'getDeclaredConstructors')
                                or
                                starts-with(@Image,'AccessibleObject.setAccessible')
                                ])
                        )
                        and
                        (//ImportDeclaration/Name[
                                contains(@Image,'java.security.PrivilegedAction')])
                ]
                
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
            

			import java.lang.reflect.AccessibleObject;
			import java.lang.reflect.Method;
			import java.security.PrivilegedAction;

			public class Violation {
				public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
					// Possible call to forbidden getDeclaredConstructors
					Class[] arrayOfClass = new Class[1];
					this.getClass().getDeclaredConstructors();
					this.getClass().getDeclaredConstructor(arrayOfClass);
					Class clazz = this.getClass();
					clazz.getDeclaredConstructor(arrayOfClass);
					clazz.getDeclaredConstructors();

					// Possible call to forbidden setAccessible
					clazz.getMethod("", arrayOfClass).setAccessible(false);
					AccessibleObject.setAccessible(null, false);
					Method.setAccessible(null, false);
					Method[] methodsArray = clazz.getMethods();
					int nbMethod;
					for ( nbMethod = 0; nbMethod < methodsArray.length; nbMethod++ ) {
						methodsArray[nbMethod].setAccessible(false);
					}

					// Possible call to forbidden PrivilegedAction
					PrivilegedAction priv = (PrivilegedAction) new Object(); priv.run();
				}
			}
					
			]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="HASHTABLE_VECTOR: Consider replacing this Hashtable with the newer java.util.Map" name="ReplaceHashtableWithMap" typeResolution="true">
      <description>Consider replacing this Hashtable with the newer java.util.Map</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//Type/ReferenceType/ClassOrInterfaceType[@Image='Hashtable']
     
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
     void bar() {
        Hashtable h = new Hashtable();
     }
    }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid using enum as an identifier; it's a reserved word in JDK 1.5" name="AvoidEnumAsIdentifier" typeResolution="true">
      <description>Finds all places where 'enum' is used as an identifier.</description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//VariableDeclaratorId[@Image='enum']
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
    public class A {
        public  class foo {
            String enum = "foo";
        }
    }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid using assert as an identifier; it's a reserved word in JDK 1.4" name="AvoidAssertAsIdentifier" typeResolution="true">
      <description>Finds all places where 'assert' is used as an identifier.</description>
      <priority>5</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//VariableDeclaratorId[@Image='assert']
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
    public class A {
        public  class foo {
            String assert = "foo";
        }
    }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Avoid instantiating Integer objects. Call Integer.valueOf() instead." name="IntegerInstantiation" typeResolution="true">
      <description>In JDK 1.5, calling new Integer() causes memory allocation.  Integer.valueOf() is more memory friendly.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//PrimaryPrefix
 /AllocationExpression
  [not (ArrayDimsAndInits)
   and (ClassOrInterfaceType/@Image='Integer'
    or ClassOrInterfaceType/@Image='java.lang.Integer')]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
 private Integer i = new Integer(0); // change to Integer i = Integer.valueOf(0);
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Avoid instantiating Byte objects. Call Byte.valueOf() instead" name="ByteInstantiation" typeResolution="true">
      <description>In JDK 1.5, calling new Byte() causes memory allocation. Byte.valueOf() is more memory friendly.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
          
//PrimaryPrefix/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Byte'
or ClassOrInterfaceType/@Image='java.lang.Byte')]
          
          ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
private Byte i = new Byte(0); // change to Byte i =
Byte.valueOf(0);
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Avoid instantiating Short objects. Call Short.valueOf() instead" name="ShortInstantiation" typeResolution="true">
      <description>In JDK 1.5, calling new Short() causes memory allocation. Short.valueOf() is more memory friendly.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryPrefix
/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Short'
or ClassOrInterfaceType/@Image='java.lang.Short')]

          ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
private Short i = new Short(0); // change to Short i =
Short.valueOf(0);
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="WRAPPER_INSTANZIIERUNG: Avoid instantiating Long objects.Call Long.valueOf() instead" name="LongInstantiation" typeResolution="true">
      <description>In JDK 1.5, calling new Long() causes memory allocation. Long.valueOf() is more memory friendly.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryPrefix
/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Long'
or ClassOrInterfaceType/@Image='java.lang.Long')]

    ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class Foo {
private Long i = new Long(0); // change to Long i =
Long.valueOf(0);
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.imports.DuplicateImportsRule" dfa="false" externalInfoUrl="" message="TOTE_IMPORTS: Avoid duplicate imports such as ''{0}''" name="DuplicateImports" typeResolution="true">
      <description>Avoid duplicate import statements.</description>
      <priority>3</priority>
      <example><![CDATA[import java.lang.String;
import java.lang.*;
public class Foo {}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.imports.DontImportJavaLang" dfa="false" externalInfoUrl="" message="TOTE_IMPORTS: Avoid importing anything from the package 'java.lang'" name="DontImportJavaLang" typeResolution="true">
      <description>Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).</description>
      <priority>3</priority>
      <example><![CDATA[// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.imports.ImportFromSamePackageRule" dfa="false" externalInfoUrl="" message="No need to import a type that lives in the same package" name="ImportFromSamePackage" typeResolution="true">
      <description>
 No need to import a type that lives in the same package.
     </description>
      <priority>5</priority>
      <example><![CDATA[
 
 package foo;
 import foo.Buz; // no need for this
 import foo.*; // or this
 public class Bar{}
 
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.optimization.UseStringBufferForStringAppends" dfa="false" externalInfoUrl="" message="Prefer StringBuffer over += for concatenating strings" name="UseStringBufferForStringAppends" typeResolution="true">
      <description>
Finds usages of += for appending strings.
           </description>
      <priority>5</priority>
      <example><![CDATA[
      
public class Foo {
 void bar() {
  String a;
  a = "foo";
  a += " bar";
  // better would be:
  // StringBuffer a = new StringBuffer("foo");
  // a.append(" bar);
 }
}
      
           ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.optimization.LocalVariableCouldBeFinal" dfa="false" externalInfoUrl="" message="KONSTANTHEIT_VERSTECKTE: Local variable ''{0}'' could be declared final" name="LocalVariableCouldBeFinal" typeResolution="true">
      <description>A local variable assigned only once can be declared final.</description>
      <priority>3</priority>
      <example><![CDATA[public class Bar {
 public void foo () {
  String a = "a"; //if a will not be assigned again it is better to do this:
  final String b = "b";
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="HASHTABLE_VECTOR: Use ArrayList instead of Vector" name="UseArrayListInsteadOfVector" typeResolution="true">
      <description>ArrayList is a much better Collection implementation than Vector.</description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//AllocationExpression
 /ClassOrInterfaceType[@Image='Vector' or @Image='java.util.Vector']

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[public class SimpleTest extends TestCase {
 public void testX() {
  Collection c = new Vector();
  // This achieves the same with much better performance
  // Collection c = new ArrayList();
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.optimization.UnnecessaryWrapperObjectCreation" dfa="false" externalInfoUrl="" message="WRAPPER_UEBERFLUESSIGE: Unnecessary wrapper object creation" name="UnnecessaryWrapperObjectCreation" typeResolution="true">
      <description>Parsing method should be called directy instead.</description>
      <priority>3</priority>
      <example><![CDATA[public int convert(String s) {
  int i, i2;

  i = Integer.valueOf(s).intValue(); // this wastes an object
  i = Integer.parseInt(s); // this is better

  i2 = Integer.valueOf(i).intValue(); // this wastes an object
  i2 = i; // this is better

  return i2;
}]]></example>
   </rule>
</ruleset>
